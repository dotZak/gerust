use crate::state::AppState;
use axum::{extract::Path, extract::State, http::StatusCode, Json};
use {{db_crate_name}}::{entities, transaction, Error};
use pacesetter::web::internal_error;
use tracing::info;
use uuid::Uuid;

pub async fn create(
    State(app_state): State<AppState>,
    Json({{entity_singular_name}}): Json<() /* e.g.entities::{{entity_plural_name}}::{{entity_struct_name}}Changeset */>,
) -> Result<() /* e.g. (StatusCode, Json<entities::{{entity_plural_name}}::{{entity_struct_name}}>) */, (StatusCode, String)> {
    todo!("create resource via {{db_crate_name}}'s APIs, trace, and respond!")

    /* Example:
    match entities::{{entity_plural_name}}::create({{entity_singular_name}}, &app_state.db_pool).await {
        Ok({{entity_singular_name}}) => Ok((StatusCode::CREATED, Json({{entity_singular_name}}))),
        Err(Error::ValidationError(e)) => {
            info!(err.msg = %e, err.details = ?e, "Validation failed");
            Err((StatusCode::UNPROCESSABLE_ENTITY, e.to_string()))
        }
        Err(e) => Err((internal_error(e), "".into())),
    }
    */
}

pub async fn read_all(
    State(app_state): State<AppState>,
) -> Result<() /* e.g. Json<Vec<entities::{{entity_plural_name}}::{{entity_struct_name}}>> */, StatusCode> {
    todo!("load resources via {{db_crate_name}}'s APIs, trace, and respond!")

    /* Example:
    let {{entity_plural_name}} = entities::{{entity_plural_name}}::load_all(&app_state.db_pool)
        .await
        .map_err(internal_error)?;

    info!("responding with {:?}", {{entity_plural_name}});

    Ok(Json({{entity_plural_name}}))
    */
}

pub async fn read_one(
    State(app_state): State<AppState>,
    Path(id): Path<Uuid>,
) -> Result<() /* e.g. Json<entities::{{entity_plural_name}}::{{entity_struct_name}}> */, StatusCode> {
    todo!("load resource via {{db_crate_name}}'s APIs, trace, and respond!")

    /* Example:
    match entities::{{entity_plural_name}}::load(id, &app_state.db_pool).await {
        Ok({{entity_singular_name}}) => Ok(Json({{entity_singular_name}})),
        Err(Error::NoRecordFound) => Err(StatusCode::NOT_FOUND),
        Err(e) => Err(internal_error(e)),
    }
    */
}

pub async fn update(
    State(app_state): State<AppState>,
    Path(id): Path<Uuid>,
    Json({{entity_singular_name}}): Json<() /* e.g. entities::{{entity_plural_name}}::{{entity_struct_name}}Changeset */>,
) -> Result<() /* e.g. Json<entities::{{entity_plural_name}}::{{entity_struct_name}}> */, (StatusCode, String)> {
    todo!("update resource via {{db_crate_name}}'s APIs, trace, and respond!")

    /* Example:
    match entities::{{entity_plural_name}}::update(id, {{entity_singular_name}}, &app_state.db_pool).await {
        Ok({{entity_singular_name}}) => Ok(Json({{entity_singular_name}})),
        Err(Error::NoRecordFound) => Err((StatusCode::NOT_FOUND, "".into())),
        Err(Error::ValidationError(e)) => {
            info!(err.msg = %e, err.details = ?e, "Validation failed");
            Err((StatusCode::UNPROCESSABLE_ENTITY, e.to_string()))
        }
        Err(e) => Err((internal_error(e), "".into())),
    }
    */
}

pub async fn delete(
    State(app_state): State<AppState>,
    Path(id): Path<Uuid>,
) -> Result<StatusCode, (StatusCode, String)> {
    todo!("delete resource via {{db_crate_name}}'s APIs, trace, and respond!")

    /* Example:
    match entities::{{entity_plural_name}}::delete(id, &app_state.db_pool).await {
        Ok(_) => Ok(StatusCode::NO_CONTENT),
        Err(Error::NoRecordFound) => Err((StatusCode::NOT_FOUND, "".into())),
        Err(e) => Err((internal_error(e), "".into())),
    }
    */
}
