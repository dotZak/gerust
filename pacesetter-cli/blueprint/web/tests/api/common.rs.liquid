use axum::{
    body::{Body, Bytes},
    http::{Method, Request},
    response::Response,
    Router,
};
{%- if template_type != "minimal" -%}
use {{crate_name}}_config::{load_config, Config, DatabaseConfig, Environment};
use {{crate_name}}_db::connect_pool;
use {{crate_name}}_web::routes::routes;
use {{crate_name}}_web::state::AppState;
use rand::distributions::Alphanumeric;
use rand::{thread_rng, Rng};
use regex::{Captures, Regex};
use sqlx::postgres::{PgConnectOptions, PgConnection};
use sqlx::{Connection, Executor, PgPool};
use std::cell::OnceCell;
use std::collections::HashMap;
use std::str::FromStr;
use std::sync::Arc;
{%- else -%}
use {{crate_name}}_config::{load_config, Config, Environment};
use {{crate_name}}_web::routes::routes;
use {{crate_name}}_web::state::AppState;
use std::cell::OnceCell;
use std::collections::HashMap;
{%- endif -%}
use tower::ServiceExt;

#[allow(unused)]
pub async fn request(
    app: &Router,
    uri: &str,
    headers: HashMap<&str, &str>,
    body: Body,
    method: Method,
) -> Response {
    let mut request_builder = Request::builder().uri(uri);

    for (key, value) in headers {
        request_builder = request_builder.header(key, value);
    }

    request_builder = request_builder.method(method);

    let request = request_builder.body(body);

    app.clone().oneshot(request.unwrap()).await.unwrap()
}

#[allow(unused)]
pub async fn response_body(response: Response<Body>) -> Bytes {
    // We don't care about the size limit in tests.
    axum::body::to_bytes(response.into_body(), usize::MAX)
        .await
        .expect("Failed to read response body")
}

#[allow(unused)]
pub async fn response_body_json<T>(response: Response<Body>) -> T
where
    T: serde::de::DeserializeOwned,
{
    let body = response_body(response).await;
    serde_json::from_slice::<T>(&body).expect("Failed to deserialize JSON body")
}

{%- if template_type != "minimal" -%}
pub struct DbTestContext {
    /// The application that is being tested.
    pub app: Router,
    /// A connection pool connected to the same database that the application that is being tested uses as well.
    pub db_pool: PgPool,
}

#[allow(unused)]
pub async fn setup_with_db() -> DbTestContext {
    let init_config: OnceCell<Config> = OnceCell::new();
    let config = init_config.get_or_init(|| load_config(&Environment::Test).unwrap());

    let test_db_config = prepare_db(&config.database).await;
    let db_pool = connect_pool(test_db_config)
        .await
        .expect("Could not connect to database!");

    let app = routes(AppState {
        db_pool: db_pool.clone(),
    });

    build_db_test_context(app, db_pool)
}

#[allow(unused)]
pub async fn teardown_with_db(context: DbTestContext) {
    drop(context.app);

    let mut connect_options = context.db_pool.connect_options();
    let db_config = Arc::make_mut(&mut connect_options);

    drop(context.db_pool);

    let root_db_config = db_config.clone().database("postgres");
    let mut connection: PgConnection = Connection::connect_with(&root_db_config).await.unwrap();

    let test_db_name = db_config.get_database().unwrap();

    let query = format!("DROP DATABASE IF EXISTS {}", test_db_name);
    connection.execute(query.as_str()).await.unwrap();
}

pub fn build_db_test_context(router: Router, db_pool: PgPool) -> DbTestContext {
    DbTestContext {
        app: router,
        db_pool,
    }
}

pub async fn prepare_db(config: &DatabaseConfig) -> DatabaseConfig {
    let db_config = parse_db_config(&config.url);
    let db_name = db_config.get_database().unwrap();

    let root_db_config = db_config.clone().database("postgres");
    let mut connection: PgConnection = Connection::connect_with(&root_db_config).await.unwrap();

    let test_db_name = build_test_db_name(db_name);

    let query = format!("CREATE DATABASE {} TEMPLATE {}", test_db_name, db_name);
    connection.execute(query.as_str()).await.unwrap();

    let regex = Regex::new(r"(.+)\/(.+$)").unwrap();
    let test_db_url = regex.replace(&config.url, |caps: &Captures| {
        format!("{}/{}", &caps[1], test_db_name)
    });

    DatabaseConfig {
        url: test_db_url.to_string(),
    }
}

fn build_test_db_name(base_name: &str) -> String {
    let test_db_suffix: String = thread_rng()
        .sample_iter(&Alphanumeric)
        .take(30)
        .map(char::from)
        .collect();
    format!("{}_{}", base_name, test_db_suffix).to_lowercase()
}

fn parse_db_config(url: &str) -> PgConnectOptions {
    PgConnectOptions::from_str(url).expect("Invalid DATABASE_URL!")
}
{% else %}
pub struct TestContext {
    /// The application that is being tested.
    pub app: Router,
}

pub fn build_test_context(router: Router) -> TestContext {
    TestContext { app: router }
}

pub async fn setup() -> TestContext {
    let init_config: OnceCell<Config> = OnceCell::new();
    let _config = init_config.get_or_init(|| load_config(&Environment::Test).unwrap());

    let app = routes(AppState {});

    build_test_context(app)
}
{%- endif %}
